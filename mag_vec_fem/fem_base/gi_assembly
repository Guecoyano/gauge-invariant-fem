def load_mesh(h,L):
    with open(
        os.path.realpath(os.path.join(data_path, "Th", "h" + str(int(1 / h)) + ".pkl")),
        "rb",
    ) as f:
        Th = pickle.load(f)
        Th.q = L * Th.q
        Th.vols = (L**2) * Th.vols
    return Th

def circ_A(Th,A0):
    c_A=np.zeros(Th.nme,Th.d+1,Th.d+1)
    A_edges=np.zeros(Th.nme,Th.d+1,Th.d+1,Th.d)
    edges=np.zeros(Th.nme,Th.d+1,Th.d+1,Th.d)
    q=Th.q
    for i in range(Th.d+1):
        for j in range(i):
            A_edges[:,i,j]=1/2*(A0(q[Th.me[:,i],0],q[Th.me[:,i],1])+A0(q[Th.me[:,j],0],q[Th.me[:,j],1]))
            A_edges[:,j,i]=-A_edges[:,i,j]
            edges[:,i,j]=(q[Th.me[:,i],0],q[Th.me[:,i],1])
            #c_A=np.

    return

def Kg_kinetic_mag(q,circulation_A):
    d=2
    ndfe=d+1
    G = FEMtools.ComputeGradientVec(Th.q, Th.me, Th.vols)
    mu = np.zeros((Th.nme, ndfe, ndfe), complex)
    for i in range(d):
        mu += Kg_gdudv(Th, 1, G, i, i, complex)

    Kg_A = np.zeros((Th.nme, ndfe, ndfe), complex)
    for i in range(d + 1):
        for j in range(i):
            Kg_A[:, i, i] = Kg_A[:, i, i] + mu[:, i, j]
            Kg_A[:, j, j] = Kg_A[:, j, j] + mu[:, i, j]

    phi=np.exp(circulation_A* 1j)
    for i in range(d + 1):
        for j in range(i):
            Kg_A[:, i, j] = Kg_A[:, i, j] - np.multiply(mu[:, i, j], phi[:, i, j])
            Kg_A[:, j, i] = Kg_A[:, j, i] - np.multiply(mu[:, i, j], phi[:, j, i])
    return Kg_A
    


def assembly(Th,V,gauge,beta):
    d=2
    Kg_V=Kg = Kg_guv(Th, V, complex)
    A0=lambda x,y: globals()["A_" + gauge](x, y)
    circulation_A=circ_A(Th,beta*A0)
    Kg_A=Kg_kinetic_mag(Th,circulation_A)
    Kg=Kg_V+Kg_A
    Ig, Jg = IgJgP1_OptV3(d, Th.nme, Th.me)
    N_mat_elem = Th.nme * (Th.d + 1) ** 2
    A = sparse.csc_matrix(
        (np.reshape(Kg, N_mat_elem), (np.reshape(Ig, N_mat_elem), np.reshape(Jg, N_mat_elem))),
        shape=(Th.nq, Th.nq),
    )
    A.eliminate_zeros()
    return A

def get_eigvv(Th,V,beta,**kwargs):
    gauge = kwargs.get("gauge", "LandauX")
    ml = kwargs.get("mass_lumping", False)
    Tcpu = np.zeros((4,))
    tstart = time.time()
    
    A_0 = assembly(
        ml,
        Th,
        V,
        gauge,
        beta
    )
    if ml:
        Kg = KgP1_OptV3_ml(Th, 1, complex)
    else:
        Kg = KgP1_OptV3_guv(Th, 1, complex)

    Ig, Jg = IgJgP1_OptV3(Th.d, Th.nme, Th.me)
    NN = Th.nme * (Th.d + 1) ** 2
    M = sparse.csc_matrix(
        (np.reshape(Kg, NN), (np.reshape(Ig, NN), np.reshape(Jg, NN))),
        shape=(Th.nq, Th.nq),
    )
    M.eliminate_zeros()

    Tcpu[0] = time.time() - tstart
    ndof = A_0.get_shape()[0]
    tstart = time.time()
    Tcpu[1] = time.time() - tstart
    tstart = time.time()
    # bN=NeumannBC(pde,AssemblyVersion,Num);
    [AR, bR] = RobinBC(magpde, AssemblyVersion, Num)
    [ID, IDc, gD] = DirichletBC(magpde, Num)
    A = A_0 + AR
    Tcpu[2] = time.time() - tstart
    x = np.zeros((ndof, N), dtype=magpde.dtype)
    w = np.zeros(N, dtype=complex)
    tstart = time.time()
    xx = np.repeat(gD[ID], N, axis=0)
    x[ID, :] = np.reshape(xx, (len(ID), -1))
    E_0 = B / 2
    t = kwargs.get("target_energy", E_0)
    print("solving...")
    w, x[IDc, :] = eigsh(
        (A[IDc])[::, IDc], M=(M[IDc])[::, IDc], k=N, sigma=t, which="LM"
    )
    Tcpu[3] = time.time() - tstart

    print("times:", Tcpu)

    return w, x