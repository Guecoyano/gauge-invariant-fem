# coding=utf-8
import numpy as np
import fem_base.gaugeInvariantFEM as gi
from fem_base.mesh import HyperCube
from fem_base.graphics import *
from fem_base.potentials import interpolate_pot
import matplotlib
import time
import os
import sys
from os import getcwd
from os.path import dirname

d = 2

def variable_value(variablestring,is_string, argstring):
    for arg in argstring:
        string,value=arg.split('=')
        if variablestring == string:
            if is_string:    
                return value
            else:
                return eval(value)
    return None

data_path = os.path.realpath(os.path.join(os.path.dirname(__file__), "..", "data"))

"""def res_path_f():
    directory = getcwd()
    if __file__.startswith(directory+'/'):
        file= __file__.replace(directory+'/', '',1)
    else:
        print('file and directory error')
    return dirname(file)"""
# nameV=os.path.realpath(os.path.join(data_path,'pre_interp_pot',f'pre_interp_potv{pot_version}l{lnm}E1eVx15.npy'))


def vth_data(h, namepot, **kwargs):
    Th = kwargs.get("Th", None)
    if Th == None:
        print("Creating mesh")
        Th = HyperCube(2, int(1 / h), l=1)
        print("Mesh done")
    print("Creating potential")
    N_a = kwargs.get("N_a", 400)
    lnm = kwargs.get("lnm", None)
    if lnm != None:
        nameq = os.path.realpath(
            os.path.join(data_path, "Vq", f"Vql{lnm}.npy")
        )
    else:
        nameq = os.path.realpath(
            os.path.join(data_path, "Vq", f"VqNa{N_a}.npy")
        )
    path_to_pot = os.path.realpath(
        os.path.join(data_path, "pre_interp_pot", f"{namepot}.npy")
    )
    V_preinterp = np.load(path_to_pot)
    V_preinterp = V_preinterp / np.max(V_preinterp)
    points = np.load(nameq)
    points = points * 1 / (np.max(points) + np.max(-points))
    V = interpolate_pot(V_preinterp, points, Th.q)
    print("Potential set")
    return V, Th


def getsave_eig(namepot, V_1, NV, Th, h, NB, gauge, N_eig, **kwargs):
    V_max, B = NV**2, NB**2
    E_0 = B / 2
    res_path = kwargs.get("res_path", data_path)
    dir_to_save = kwargs.get("dir_to_save", None)
    t_e = kwargs.get("target_energy", E_0)
    ml = kwargs.get("mass_lumping", True)
    V = V_max * V_1
    print(
        f"Get first {N_eig} eigenfunctions : 2D Magnetic Schrödinger {namepot}"
    )
    w, x = gi.get_eigvv(
        N=N_eig, B=B, h=h, gauge=gauge, V=V, Th=Th, target_energy=t_e, mass_lumping=ml
    )
    print("Ordering eigendata")
    tstart = time.time()

    # ordering eigenstates:
    wtype = [("energy", float), ("rank", int)]
    w_ = [(w[i], i) for i in range(N_eig)]
    w_disordered = np.array(w_, dtype=wtype)
    w_ord = np.sort(w_disordered, axis=0, order="energy")
    I = [i[1] for i in w_ord]
    w = np.array([i[0] for i in w_ord])
    x_ = np.copy(x)
    for i in range(N_eig):
        x[:, i] = x_[:, I[i]]
    t_order = time.time() - tstart
    print("ordering time:", t_order)
    tstart = time.time()

    print("Post-processing")
    # save in one compressed numpy file: V in nq array, th.q , w ordered in N_eig array, x ordered in nq*N_eig array
    if dir_to_save is None:
        dir_to_save = os.path.realpath(os.path.join(res_path, "eigendata"))
    dir_to_save = os.path.join(
        dir_to_save,
        f"{namepot}NV{NV}NB{NB}{gauge}h{int(1 / h)}Neig{N_eig}"
    )
    np.savez_compressed(dir_to_save, q=Th.q, V=V, eig_val=w, eig_vec=x)
    t_postpro = time.time() - tstart
    print("saving time:", t_postpro)
    return


'''def getsave_eig_ml(namepot, V_1, NV, Th, h, NB, gauge, N_eig, **kwargs):
    V_max, B = NV**2, NB**2
    E_0 = B / 2
    res_path = kwargs.get("res_path", data_path)
    dir_to_save = kwargs.get("dir_to_save", None)
    t_e = kwargs.get("target_energy", E_0)
    V = V_max * V_1
    print(
        "Get first {N_eig} eigenfunctions : 2D Magnetic Schrödinger "
        + namepot
    )
    w, x = gi.get_eigvv_ml(
        N=N_eig, B=B, h=h, gauge=gauge, V=V, Th=Th, target_energy=t_e
    )
    print("Ordering eigendata")
    tstart = time.time()

    # ordering eigenstates:
    wtype = [("energy", float), ("rank", int)]
    w_ = [(w[i], i) for i in range(N_eig)]
    w_disordered = np.array(w_, dtype=wtype)
    w_ord = np.sort(w_disordered, axis=0, order="energy")
    I = [i[1] for i in w_ord]
    w = np.array([i[0] for i in w_ord])
    x_ = np.copy(x)
    for i in range(N_eig):
        x[:, i] = x_[:, I[i]]
    t_order = time.time() - tstart
    print("ordering time:", t_order)
    tstart = time.time()

    print("Post-processing")
    # save in one compressed numpy file: V in nq array, th.q , w ordered in N_eig array, x ordered in nq*N_eig array
    if dir_to_save is None:
        dir_to_save = os.path.realpath(os.path.join(res_path, "eigendata"))
    dir_to_save = os.path.join(
        dir_to_save,f"{namepot}NV{NV}NB{NB)
        + gauge
       }h{int(1 / h)}Neig{N_eig),
    )
    np.savez_compressed(dir_to_save, q=Th.q, V=V, eig_val=w, eig_vec=x)
    t_postpro = time.time() - tstart
    print("saving time:", t_postpro)
    return'''


def get_eigplots(N_eig, B, namepot, V, V_max, Th, h, gauge, **kwargs):
    E_0 = B / 2
    res_path = kwargs.get("res_path", data_path)
    t_e = kwargs.get("target_energy", E_0)
    l = 1
    Mod = kwargs.get("Modulus", True)
    Im = kwargs.get("Imaginary", False)
    Re = kwargs.get("Real", False)
    phase = kwargs.get("Phase", False)
    color = kwargs.get("color", "turbo")
    ml = kwargs.get("mass_lumping", True)

    print("Get first {N_eig} eigenfunctions : 2D Magnetic Schrödinger")
    w, x = gi.get_eigvv(
        N=N_eig, B=B, h=h, gauge=gauge, V=V, Th=Th, target_energy=t_e, mass_lumping=ml
    )
    tstart = time.time()
    # ordering eigenstates:
    print("Ordering eigendata")
    wtype = [("energy", float), ("rank", int)]
    w_ = [(w[i], i) for i in range(N_eig)]
    w_disordered = np.array(w_, dtype=wtype)
    w_ord = np.sort(w_disordered, axis=0, order="energy")
    I = [i[1] for i in w_ord]
    w = np.array([i[0] for i in w_ord])
    x_ = np.copy(x)
    for i in range(N_eig):
        x[:, i] = x_[:, I[i]]
        t_order = time.time() - tstart
    tstart = time.time()
    print("Post-processing")
    print(w)
    n = 1
    plt.close()
    for i in w:
        print(n)
        E_proxy = "{:.2e}".format(w[n - 1])

        if Mod:
            plt.figure(3 * n - 2)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, np.abs(x[:, n - 1]), fill=True, colorbar=True, color=color)
            ti, tle = (
                "2D Magnetic Schrödinger : eigenfunction {n} ",
                " $E_{{n}}={E_proxy}$)",
            )
            t1 = os.path.join(
                "eigenplots",
                f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_mod.png"
            )
            plt.title(f"{ti}(modulus){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t1)))
            plt.clf()
            plt.close(3 * n - 2)

        if Re:
            plt.figure(3 * n - 1)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, (x[:, n - 1]).real, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t2 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_real"
            )
            plt.title(f"{ti}(real part){tle}")
            plt.savefig(res_path + t2)
            plt.close(3 * n - 1)

        if Im:
            plt.figure(3 * n)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, x[:, n - 1].imag, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t3 = os.path.join(
                "eigenplots",
                f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_im.png"
            )
            plt.title(f"{ti}(imaginary part){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t3)))
            plt.close(3 * n)

        if phase:
            plt.figure(3 * n)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(
                Th,
                np.angle(x[:, n - 1]),
                fill=True,
                colorbar=True,
                color="twilight",
            )
            t4 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_phase.png",
            )
            plt.title(f"{ti}(phase){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t4)))
            plt.close(3 * n)

        n += 1
    t_postpro = time.time() - tstart
    print("ordering time", t_order)
    print("postprocessing time", t_postpro)
    return


'''def get_eigplots_ml(N_eig, B, namepot, V, V_max, Th, h, gauge, **kwargs):
    E_0 = B / 2
    res_path = kwargs.get("res_path", data_path)
    t_e = kwargs.get("target_energy", E_0)
    l = 1
    Mod = kwargs.get("Modulus", True)
    Im = kwargs.get("Imaginary", False)
    Re = kwargs.get("Real", False)
    phase = kwargs.get("Phase", False)
    color = kwargs.get("color", "turbo")

    print("Get first {N_eig} eigenfunctions : 2D Magnetic Schrödinger")
    w, x = gi.get_eigvv_ml(
        N=N_eig, B=B, h=h, gauge=gauge, V=V, Th=Th, target_energy=t_e
    )
    tstart = time.time()
    # ordering eigenstates:
    print("Ordering eigendata")
    wtype = [("energy", float), ("rank", int)]
    w_ = [(w[i], i) for i in range(N_eig)]
    w_disordered = np.array(w_, dtype=wtype)
    w_ord = np.sort(w_disordered, axis=0, order="energy")
    I = [i[1] for i in w_ord]
    w = np.array([i[0] for i in w_ord])
    x_ = np.copy(x)
    for i in range(N_eig):
        x[:, i] = x_[:, I[i]]
        t_order = time.time() - tstart
    tstart = time.time()
    print("Post-processing")
    print(w)
    n = 1
    plt.close()
    for i in w:
        print(n)
        E_proxy = "{:.2e}".format(w[n - 1])

        if Mod:
            plt.figure(3 * n - 2)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, np.abs(x[:, n - 1]), fill=True, colorbar=True, color=color)
            ti, tle = (
                "2D Magnetic Schrödinger : eigenfunction {n} ",
                " $E_{{n}}={E_proxy}$)",
            )
            t1 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_mod.png",
            )
            plt.title(f"{ti}(modulus){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t1)))
            plt.clf()
            plt.close(3 * n - 2)

        if Re:
            plt.figure(3 * n - 1)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, (x[:, n - 1]).real, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t2 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_real",
            )
            plt.title(f"{ti}(real part){tle}")
            plt.savefig(res_path + t2)
            plt.close(3 * n - 1)

        if Im:
            plt.figure(3 * n)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, x[:, n - 1].imag, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t3 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_im.png",
            )
            plt.title(f"{ti}(imaginary part){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t3)))
            plt.close(3 * n)

        if phase:
            plt.figure(3 * n)
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(
                Th,
                np.angle(x[:, n - 1]),
                fill=True,
                colorbar=True,
                color="twilight",
            )
            t4 = os.path.join(
                "eigenplots",f"{namepot}V{V_max}B{B}{gauge}h{int(1 / h)}eig{n}_phase.png",
            )
            plt.title(f"{ti}(phase){tle}")
            plt.savefig(os.path.realpath(os.path.join(res_path, t4)))
            plt.close(3 * n)

        n += 1
    t_postpro = time.time() - tstart
    print("ordering time", t_order)
    print("postprocessing time", t_postpro)
    return'''


def datafile(namepot, NV, NB, gauge, h, N_eig, **kwargs):
    res_path = kwargs.get("res_path", data_path)
    namedata = os.path.realpath(
        os.path.join(
            res_path,
            "eigendata", f"{namepot}NV{NV}NB{NB}{gauge}h{int(1 / h)}Neig{N_eig}.npz",
        )
    )
    return np.load(namedata, allow_pickle=True)


def read_eigplot(nfig, namepot, NV, NB, Th, data_file, Num, function_part):
    x, w = data_file["eig_vec"], data_file["eig_val"]
    n = Num
    E_proxy = "{:.2e}".format(w[n - 1])
    color = "turbo"
    if function_part == "real":
        part = np.real
    elif function_part == "imaginary":
        part = np.imag
    elif function_part == "modulus":
        part = np.abs
    elif function_part == "phase":
        part = np.angle
        color = "twilight"
    plt.figure(nfig)
    plt.clf()
    # PlotBounds(Th,legend=False,color='k')
    plt.axis("off")
    PlotIsolines(Th, part(x[:, n - 1]), fill=True, colorbar=True, color=color)
    ti, tle = (f"{namepot}NV={NV} NB={NB}: eigenfunction {n} ",
        " $E_{{n}}={E_proxy}$)",
    )
    plt.title(f"{ti}({function_part}){tle}")
    return


def save_eigplot(nfig, lnm, Th, data_file, Num, function_part, name_preeig, **kwargs):
    res_path = kwargs.get("res_path", data_path)
    x, w = data_file["eig_vec"], data_file["eig_val"]
    n = Num
    E_proxy = "{:.2e}".format(w[n - 1])
    color = kwargs.get("color", "turbo")
    if function_part == "real":
        part = np.real
    elif function_part == "imaginary":
        part = np.imag
    elif function_part == "modulus":
        part = np.abs
    elif function_part == "phase":
        part = np.angle
        color = "twilight"
    plt.figure(nfig)
    plt.clf()
    # PlotBounds(Th,legend=False,color='k')
    plt.axis("off")
    PlotIsolines(Th, part(x[:, n - 1]), fill=True, colorbar=True, color=color)
    ti, tle = (
        "Eigenfunction {n} ",
        " $E_{{n}}={E_proxy}$)",
    )
    if function_part == "real" or function_part == "imaginary":
        matplotlib.colors.CenteredNorm()
    t1 = os.path.join(
        "loose_eigenplots",
        f"{name_preeig}eig{n}_{function_part}.png",
    )
    plt.title(f"{ti}{function_part}{tle}")
    plt.savefig(os.path.realpath(os.path.join(res_path, t1)))
    plt.close()
    return


def saveplots_fromdata(Th, data_file, name_preeig, **kwargs):
    dir_to_save = kwargs.get("dir_to_save", data_path)
    Mod = kwargs.get("modulus", True)
    Im = kwargs.get("imaginary", False)
    Re = kwargs.get("real", False)
    Phase = kwargs.get("phase", False)
    color = kwargs.get("color", "turbo")
    x, w = data_file["eig_vec"], data_file["eig_val"]
    n = 1
    if not os.path.exists(
        os.path.realpath(os.path.join(dir_to_save, name_preeig))
    ):
        os.makedirs(os.path.realpath(os.path.join(dir_to_save, name_preeig)))
        os.makedirs(
            os.path.realpath(
                os.path.join(dir_to_save, name_preeig, "modulus")
            )
        )
        os.makedirs(
            os.path.realpath(os.path.join(dir_to_save, name_preeig, "real"))
        )
        os.makedirs(
            os.path.realpath(
                os.path.join(dir_to_save, name_preeig, "imaginary")
            )
        )
        os.makedirs(
            os.path.realpath(os.path.join(dir_to_save, name_preeig, "phase"))
        )

    for i in w:
        if (n - 1) / 10 == (n - 1) // 10:
            print(n)
        E_proxy = "{:.3e}".format(w[n - 1])

        if Mod:
            f = plt.figure()
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, np.abs(x[:, n - 1]), fill=True, colorbar=True, color=color)
            ti, tle = (
                f"Eigenfunction {n} ",
                " $E_{" + str(n) + "}" + f"={E_proxy}" + "$)",
            )
            t1 = os.path.join(
                name_preeig,
                "modulus",
                f"eig{n}_mod.png",
            )
            plt.title(f"{ti}(modulus){tle}")
            plt.savefig(os.path.realpath(os.path.join(dir_to_save, t1)))
            plt.clf()
            plt.close()

        if Re:
            f = plt.figure()
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, (x[:, n - 1]).real, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t2 = os.path.join(name_preeig, "real", f"eig{n}_real")
            plt.title(f"{ti}(real part){tle}")
            plt.savefig(os.path.realpath(os.path.join(dir_to_save, t2)))
            plt.clf()
            plt.close()

        if Im:
            f = plt.figure()
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(Th, x[:, n - 1].imag, fill=True, colorbar=True, color=color)
            matplotlib.colors.CenteredNorm()
            t3 = os.path.join(
                name_preeig,
                "imaginary",
                f"eig{n}_im.png",
            )
            plt.title(f"{ti}(imaginary part){tle}")
            plt.savefig(os.path.realpath(os.path.join(dir_to_save, t3)))
            plt.clf()
            plt.close()

        if Phase:
            f = plt.figure()
            plt.clf()
            PlotBounds(Th, legend=False, color="k")
            plt.axis("off")
            PlotIsolines(
                Th,
                np.angle(x[:, n - 1]),
                fill=True,
                colorbar=True,
                color="twilight",
            )
            t4 = os.path.join(
                name_preeig,
                "phase",
                f"eig{n}_phase.png",
            )
            plt.title(f"{ti}(imaginary part){tle}")
            plt.savefig(os.path.realpath(os.path.join(dir_to_save, t4)))
            plt.clf()
            plt.close()
        n += 1
    return


def colorscale(values, shape, edge=0.1):
    if shape == "grid":
        n = len(values)
        nedge = int(n * edge)
        sliced_values = values[nedge : n - nedge, nedge : n - nedge]
    elif shape == "hypercube":
        n = int(np.sqrt(len(values)))
        nedge = int(n * edge)
        sliced_values = []
        for i in range(nedge, n - nedge):
            sliced_values.append(values[i * n + nedge : (i + 1) * n - nedge])
        sliced_values = np.array(sliced_values)
    else:
        print('Shape should be "grid" or "hypercube"')
        return
    vmin, vmax = np.min(sliced_values), np.max(sliced_values)
    return [vmin, vmax]
